# 全网最适合入门的面向对象编程教程：23 类和对象的 Python 实现-抛出异常

![](static/ZmT8bN32Bo3BMWxImcQcwjemnIf.png)

# 摘要：

本文主要介绍了在使用 Python 面向对象编程时，异常的使用场景、定义和特点，错误的类型和特点，并举出实际例子来辅助讲解。

# 原文链接：

**FreakStudio 的博客**

# **往期推荐：**

**学嵌入式的你，还不会面向对象？？！**

**全网最适合入门的面向对象编程教程：00 面向对象设计方法导论**

**全网最适合入门的面向对象编程教程：01 面向对象编程的基本概念**

**全网最适合入门的面向对象编程教程：02 类和对象的 Python 实现-使用 Python 创建类**

**全网最适合入门的面向对象编程教程：03 类和对象的 Python 实现-为自定义类添加属性**

**全网最适合入门的面向对象编程教程：04 类和对象的 Python 实现-为自定义类添加方法**

**全网最适合入门的面向对象编程教程：05 类和对象的 Python 实现-PyCharm 代码标签**

**全网最适合入门的面向对象编程教程：06 类和对象的 Python 实现-自定义类的数据封装**

**全网最适合入门的面向对象编程教程：07 类和对象的 Python 实现-类型注解**

**全网最适合入门的面向对象编程教程：08 类和对象的 Python 实现-@property 装饰器**

**全网最适合入门的面向对象编程教程：09 类和对象的 Python 实现-类之间的关系**

**全网最适合入门的面向对象编程教程：10 类和对象的 Python 实现-类的继承和里氏替换原则**

**全网最适合入门的面向对象编程教程：11 类和对象的 Python 实现-子类调用父类方法**

**全网最适合入门的面向对象编程教程：12 类和对象的 Python 实现-Python 使用 logging 模块输出程序运行日志**

**全网最适合入门的面向对象编程教程：13 类和对象的 Python 实现-可视化阅读代码神器 Sourcetrail 的安装使用**

**全网最适合入门的面向对象编程教程：14 类和对象的 Python 实现-类的静态方法和类方法**

**全网最适合入门的面向对象编程教程：15 类和对象的 Python 实现-__slots__魔法方法**

**全网最适合入门的面向对象编程教程：16 类和对象的 Python 实现-多态、方法重写与开闭原则**

**全网最适合入门的面向对象编程教程：17 类和对象的 Python 实现-鸭子类型与“file-like object“**

**全网最适合入门的面向对象编程教程：18 类和对象的 Python 实现-多重继承与 PyQtGraph 串口数据绘制曲线图**

**全网最适合入门的面向对象编程教程：19 类和对象的 Python 实现-使用 PyCharm 自动生成文件注释和函数注释**

**全网最适合入门的面向对象编程教程：20 类和对象的 Python 实现-组合关系的实现与 CSV 文件保存**

**全网最适合入门的面向对象编程教程：21 类和对象的 Python 实现-多文件的组织：模块 module 和包 package**

**全网最适合入门的面向对象编程教程：22 类和对象的 Python 实现-异常和语法错误**

# **更多精彩内容可看：**

**给你的 Python 加加速：一文速通 Python 并行计算**

**一文搞懂 CM3 单片机调试原理**

**肝了半个月，嵌入式技术栈大汇总出炉**

**电子计算机类比赛的“武林秘籍”**

# **文档和代码获取：**

可访问如下链接进行对文档下载：

**[https://github.com/leezisheng/Doc](https://github.com/leezisheng/Doc)**

![](static/QQlxb0gQxoyMrxxqInCc4Zs9nqc.png)

**本文档主要介绍如何使用 Python 进行面向对象编程，需要读者对 Python 语法和单片机开发具有基本了解。相比其他讲解 Python 面向对象编程的博客或书籍而言，本文档更加详细、侧重于嵌入式上位机应用，以上位机和下位机的常见串口数据收发、数据处理、动态图绘制等为应用实例，同时使用 Sourcetrail 代码软件对代码进行可视化阅读便于读者理解。**

**相关示例代码获取链接如下：**

**[https://github.com/leezisheng/Python-OOP-Demo](https://github.com/leezisheng/Python-OOP-Demo)**

# 正文

在实际编程情况中，大部分的方法和构造函数对传入的参数值有一些限制，比如：常见的索引值必须是非负数，对象引用不能为空。你应该在方法开始的地方强制进行入口参数检查，如果输入非法的值，我们可以使用 raise 语句自己触发异常。

raise 语法格式如下：

**raise [Exception [, args [, traceback]]]**

语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。

例如，在创建 SensorClass 传感器类时，我们需要限制传感器 ID 在 0 到 99 之间，如果不是，则抛出异常 InvalidIDError。示例代码如下：

```bash
class SensorClass(SerialClass):
    ...
    _# 类的初始化_
    def __init__(self,port:str = "COM11",id:int = 0,state:int = RESPOND_MODE):
        if id <= 0 or id >= 99:
            _# 触发异常后，后面的代码就不会再执行_
            raise Exception("InvalidIDError:", id)
        ...
if __name__ == "__main__":
    _# 创建传感器类，ID号为100_
    s = SensorClass(port  = "COM11",
                    id      = 100,
                    state = SensorClass.RESPOND_MODE
                    )
```

代码运行结果如下：

![](static/MLv0b8LucoT4Bux0k6TcAipvnbh.png)

当抛出异常时，看起来好像立即停止了程序的执行。抛出异常之后的所有代码都不会被执行，除非处理了这一异常，程序将会退出并给出错误信息。更进一步，如果一个函数调用另外一个抛出了异常的函数，在前者中调用后者的位置之后的所有代码也不会执行。抛出异常会阻止函数调用栈中所有的执行，要么被正确地处理，要么导致解释器强制退出。

![](static/G80ebBlGMojj5HxHD7McNiavnBh.png)
